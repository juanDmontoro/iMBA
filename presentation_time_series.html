<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Unit 4. Prediction with univariate time series models</title>
    <meta charset="utf-8" />
    <meta name="author" content="Prof.¬†Juan D. Montoro-Pons" />
    <script src="libs/header-attrs/header-attrs.js"></script>
    <link href="libs/remark-css/default.css" rel="stylesheet" />
    <link href="libs/remark-css/metropolis.css" rel="stylesheet" />
    <link href="libs/remark-css/metropolis-fonts.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

.title[
# Unit 4. Prediction with univariate time series models
]
.subtitle[
## Business Analytics (iMBA)
]
.author[
### Prof.¬†Juan D. Montoro-Pons
]
.institute[
### Universitat de Val√®ncia
]
.date[
### October 2024
]

---

class: center, middle, inverse

&lt;style type="text/css"&gt;
.remark-slide-content {
  font-size: 26px;
  padding: 20px 80px 20px 80px;
}
.remark-code, .remark-inline-code {
  background: #f0f0f0;
}
.remark-code {
  font-size: 20px;
}

.tinyslide .remark-slide-content{
  font-size: 50% !important;
}

.huge .remark-code { /*Change made here*/
  font-size: 200% !important;
}
.tiny .remark-code { /*Change made here*/
  font-size: 50% !important;
}

pre {
  background: #FFBB33;
  max-width: 100%;
  overflow-x: scroll;
}
&lt;/style&gt;




# Time series prediction

--

Benchmark models: mean, naive and seasonal naive

--

Statistical models: STL, exponential smoothing and ARIMA models

---

# Observed and predicted values 

Let `\(Y_t\)` be an outcome observed over time. We have information for periods `\(t=1,2,3....T\)`, i.e. `$$Y_1, Y_2\ldots Y_T$$`

--

Goal`:` to forecast  the value of `\(Y\)` at some future point `\({T+h}\)`, with `\(h&gt;0\)`, e.g. `\({T+1}\)`. One refers to the predicted value of `\(Y\)` at point `\(T+1\)` using all information available at `\(T\)`: `$$\hat{Y}_{T+1|T}$$`

--

&gt; Let `\(Y_t\)` be weekly sales. The  dataset contains information from `\(t=1,2,3 \ldots 135\)`, with `\(t=1\)` being 2013-Week-01 and `\(t=T=135\)` being 2015-Week-31. 

--

&gt; We wish to forecast values from 2015-Week-32 to 2016-Week-05, i.e.  `\(\hat{Y}_{T+1|T}, \hat{Y}_{T+2|T}\ldots \hat{Y}_{T+26|T}\)`.

---

# Benchmark models

Sometimes simple models can be effectively used to predict rather accurately in the short term. In any case, they serve as benchmarks against which  to measure the predictive power of more sophisticated   models:

--

1. The average method: `$$\hat{Y}_{t+h|T}=\bar{Y}$$`

--

2. The na√Øve method: `$$\hat{Y}_{T+h|T}=Y_T$$`
--

3. The seasonal na√Øve method: use the same observed value for the same season of the year 
---

# Statistical models: STL decomposition

1. Assume a model for `\(Y_t\)`:
`$$Y_t=T_t+S_t+I_t$$`
--

or `$$Y_t=T_t \times S_t \times I_t$$`

--

2. Predict the trend-cycle using some non-seasonal forecast method, i.e. `$$\hat{T}_{T+h|T}$$` 

--

3. Re-seasonalize the foregoing forecast (i.e. add the seasonal component to the prediction) to form  `$$\hat{Y}_{t+h|T}$$`


---

# Statistical models: exponential smoothing


1. Simple exponential smoothing. A response at `\(T+1\)` is a weighted average of all past values
`$$\hat{Y}_{T+1|T}=\alpha Y_T+\alpha (1-\alpha) Y_{T-1}+\alpha (1-\alpha)^2 Y_{T-2}\ldots$$`The value of the smoothing parameter `\(0&lt;\alpha&lt;1\)` describes the weights attached to each observation in the past.

--

2. Holt's linear method: extends the simple exponential smoothing to allow a trend. A new smoothing parameter, `\(\beta\)`,
is included to capture how strongly the trend affects the time series.

--

3. Holt-winter's method adds a new equation to capture the seasonal component (smoothing parameter `\(\gamma\)`).

???
Introducing exponential smoothing in a time series forecast class is like teaching someone how to make the perfect smoothie with just the right blend of ingredients. Let's break down the key smoothing parameters ‚Äì alpha, beta, and gamma ‚Äì using a fun and relatable analogy:

### 1. Alpha (Level):
- **The Base Flavor**: Think of alpha as the base flavor of your smoothie. It determines how much of the most recent observation (or actual value) you're going to use in your forecast.
- **Balancing Act**: A high alpha means you're really focused on the latest taste (or data point), maybe because your preferences change rapidly. A low alpha suggests you prefer a more consistent, less reactive flavor, giving more weight to the historical blend.

### 2. Beta (Trend):
- **The Directional Boost**: Beta is like adding a directional boost to your smoothie. It's about capturing the trend in your time series.
- **Adjusting for Change**: If your smoothie tastes have been getting sweeter over time, a higher beta will make your next smoothie even sweeter, anticipating this trend. If beta is low, you're less convinced that the trend will continue, so you're more cautious in adjusting your recipe.

### 3. Gamma (Seasonal):
- **The Seasonal Twist**: Gamma adds a seasonal twist to your smoothie. It's all about those seasonal variations ‚Äì maybe you like pumpkin spice in autumn or mango in summer.
- **Embracing Seasons**: A high gamma means you really embrace these seasonal flavors, adjusting your smoothie significantly as the seasons change. A low gamma suggests that while you notice the seasons, they don't drastically change your smoothie preferences.

### Putting It All Together:
- **Perfect Blend**: In your forecasting smoothie, you‚Äôre blending the base flavor (alpha), the directional boost (beta), and the seasonal twist (gamma) to get the perfect forecast ‚Äì not too reactive, not too bland, just right for your data's taste.

- **Fine-Tuning**: Just like with smoothies, you might have to try a few blends before you get it right. Adjusting alpha, beta, and gamma helps you find that sweet spot where your forecast is just as you like it ‚Äì accurately capturing the level, trend, and seasonality of your data.

So, in your class, you're essentially teaching your students how to be master smoothie (forecast) makers, tweaking the ingredients (alpha, beta, gamma) to get the best possible taste (forecast)! üçπüìäüåü


Note that both beta and gamma in exponential smoothing models are bounded, typically within the range of 0 to 1. Let's look at each one:

1. **Beta (\(\beta\)) - Trend Component**:
   - This parameter controls the extent to which the model accounts for the trend in the time series.
   - A \(\beta\) of 0 means the model does not consider any trend information in making forecasts. It's like saying, "I don't think the direction in which things have been moving (upward or downward) will continue."
   - A \(\beta\) of 1 means the model fully incorporates the trend as it has been in the recent past. It's like betting that the trend (whether increasing or decreasing) will continue just as strongly.
   - Values between 0 and 1 represent a balance, acknowledging the trend but tempering it with some skepticism.

2. **Gamma (\(\gamma\)) - Seasonal Component**:
   - This parameter controls how much the model accounts for seasonality or periodic patterns in the data.
   - A \(\gamma\) of 0 indicates that the model does not include any seasonal variation in its forecasts, effectively saying, "Seasons or cycles? Nah, they don't affect our data."
   - A \(\gamma\) of 1 fully adjusts for seasonality, suggesting a strong belief that the seasonal pattern will repeat exactly as in the past.
   - Intermediate values suggest that the model recognizes seasonality but also considers that it might not repeat perfectly.

In both cases, setting these parameters close to 1 makes the model highly responsive to recent changes in trend or seasonality, while setting them closer to 0 makes the model more stable and less reactive to recent changes. The key is to find the right balance that accurately reflects the underlying patterns in your data without overreacting to random fluctuations.
---

# Statitical models: ARIMA

ARIMA stands for *AutoRegressive Integrated Moving Average*. Three components:

  1. AR (AutoRegressive): Predicts future values based on past values.
    
     &gt; Using yesterday's sales to predict today's.
     
  2. I (Integrated): Involves differencing the data to make it stationary.
     Removes trends and seasonality to stabilize the series.

  3. MA (Moving Average): Uses prediction errors in a regression-like model.
    Accounts for random shocks or surprises in past predictions.
    
    &gt; Yesterday's sales were abnormally good (greater than those predicted due to some
    non-expected event); using them to predict today's sales could lead to an optimistic forecast.
    An MA component accounts for how off the original forecast was (and might tame excessively
    optimistic predictions)
    

---

# Statistical models: ARIMA models


+ An autoregressive model predicts one model using past models of the variable. An AR(p)

`$$Y_t=c+\phi_1 Y_{t-1}+\phi_2 Y_{t-3}+\ldots \phi_p Y_{t-p}+\epsilon_t$$`

--

+ A moving average uses past forecast errors to predict a variable. A MA(q):

`$$Y_t=c+\epsilon_t+\theta_1 \epsilon_{t-1}+ \theta_2 \epsilon_{t-2}+\ldots +\theta_q \epsilon_{t-q}$$`

--

+ An ARMA model combines both. An ARMA(p,q):

`$$Y_t=c+\phi_1 Y_{t-1}+\phi_2 Y_{t-3}+\ldots \phi_p Y_{t-p}+\epsilon_t+\theta_1 \epsilon_{t-1}+ \theta_2 \epsilon_{t-2}+\ldots +\theta_q \epsilon_{t-q}$$`

--

+  ARIMA transforms the variable `\(Y\)` by taking differences of order `\(d\)`. We use the notation ARIMA(p,d,q).


---

# Forecasting accuracy

&gt; Different models produce different forecasts. Which one should we choose?

--

- Strategy:  split dataset into training and test set. Only the former is used to fit the model and the latter will provide a measure of out-of-sample pedictive accuracy.

--

-  The  predictive power of a model can be assessed by looking at forecasting errors, i.e. the difference between   predictions generated using the model (estimated with the training set but applied to the test set)  and actual values (those in the test set)


--

- Note that forecasting accuracy is a relative metric:  we are interested in comparing alternative models such that the model that minimizes forecasting errors is preferred 



    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false,
"ratio": "16:9"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
